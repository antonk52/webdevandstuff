<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Flow to typescript migration notes</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.6.1/github-markdown.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            box-sizing: border-box;
            margin: 0;
        }

        .markdown-body {
            min-width: 200px;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #0d1117;
            }
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --fgColor-default: #e6edf3;
            }
        }
        @media (prefers-color-scheme: light) {
            :root {
                --fgColor-default: #1f2328;
            }
        }

        header {
            display: flex;
            gap: 24px;
            border-bottom: 1px solid #e1e4e8;
            padding: 16px 24px;
        }
        header a {
            color: var(--fgColor-default);
        }
        .markdown-body h1 > a,
        .markdown-body h2 > a,
        .markdown-body h3 > a,
        .markdown-body h4 > a,
        .markdown-body h5 > a,
        .markdown-body h6 > a {
            color: var(--fgColor-default);
            text-decoration: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>

<body>
    <header>
        <a href="/webdevandstuff">Web dev and stuff</a>
        <a href="https://github.com/antonk52" target="_blank">GitHub</a>
        <a href="https://twitter.com/antonk52" target="_blank">Twitter</a>
    </header>

    <article class="markdown-body">
        <h1>Flow to typescript migration notes</h1>
        
        <p>Core difference to note when switching from flow type system to typescript. I&#39;ve been mainly using flow v0.83, if you used newer versions your experience may vary.</p>
<h2><a href="#why-static-types">Why static types</a></h2>
<ul>
<li>Documentation</li>
<li>Tests/contracts</li>
<li>DX</li>
<li>Type safety*</li>
</ul>
<h2><a href="#preword">Preword</a></h2>
<p>⚠️ - marks things to pay close attention to</p>
<h2><a href="#types-and-guarantees">Types and guarantees</a></h2>
<p><img src="https://user-images.githubusercontent.com/5817809/112736958-c8e84200-8f67-11eb-872a-216ca432c5c8.png" alt="working-with-typed-programs"></p>
<p>Types are about contract validation within your program. Unlike tests types have a chance to let the developer know what can go wrong before they finish the work.</p>
<p>DX improvement - how few things people have to keep in their head while working on a project. Types help to reduce this load.</p>
<h2><a href="#core-difference">Core difference</a></h2>
<p>Flow aims at being a sound type system. In other words flow might have false positives when raising an error.</p>
<p>Typescript aims to be a complete type system. In other words typescript might have false negatives when raising an error. See <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">non-goals</a>.</p>
<h2><a href="#language-differences">Language differences</a></h2>
<ul>
<li>Flow only provides type annotations</li>
<li>Typescript expands javascript syntax with type annotation and the following:<ul>
<li>Enums</li>
<li>Non null assertions</li>
<li><code>private</code> class properties(not <code>#name</code> syntax, it has both)</li>
<li>Decorators</li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">Parameter properties</a></li>
<li>Abstract classes</li>
<li>... <strong>TODO</strong></li>
</ul>
</li>
</ul>
<h2><a href="#structuralnominal-vs-structural-only">Structural/nominal vs structural only</a></h2>
<p>Flow has a mix of structural and <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal types</a>(classes use nominal types).</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

class Foo {
  method(input: string): number { return 42 }
}

class Bar {
  method(input: string): number { return 42 }
}

let foo: Foo = new Bar() // ERROR!!</code></pre>
<p>Typescript uses purely <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a>.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

class Foo {
  method(input: string): number { return 42 }
}

class Bar {
  method(input: string): number { return 42 }
}

let foo: Foo = new Bar() // OK</code></pre>
<!-- minor syntax diff -->

<h2><a href="#suppression-comments">Suppression comments</a></h2>
<p>Flow marks every unused suppression comment as unused if there&#39;s no error. If used <code>include_warnings=true</code> unused suppressions are marked as errors.</p>
<p>Typescript allows to have <code>// @ts-ignore</code> anywhere yet doesn&#39;t report it as an error/warning when there&#39;s no error to suppress ⚠️.</p>
<p>In <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments">v3.9</a> a <code>// @ts-expect-error</code> was added which is reported as an error where there&#39;s no error to suppress.</p>
<p>Both typescript and flow cannot suppress a specific error by error code or other methods.</p>
<h2><a href="#maybe-values">Maybe values</a></h2>
<p>Flow has maybe operator <code>?type</code> and typescript doesn&#39;t</p>
<pre class="language-"><code class="language-">// @flow

type A = ?string

// the same as
type B = string | void | null</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

type A = string | undefined | null</code></pre>
<h2><a href="#dangerous-types">Dangerous types</a></h2>
<p>In flow <code>Object</code> type can be used to describe an object that can have any key and any value.</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

const obj: Object = {}

// the same as {[string | number]: any}</code></pre>
<p>In typescript <code>Object</code> type is the actual Object constructor, which means almost every value can assigned to it</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

const bool: Object = true // ok
const str: Object = 'foo' // ok
const num: Object = 123 // ok

const nil: Object = null // err</code></pre>
<p>If you need the &quot;whatever&quot; object type in typescript you can use the <code>object</code> type with lowercase o</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

const obj1: object = {} // ok

const obj2: object = {
    a: 'string',
    b: true,
    c: 123,
    d: null,
} // ok</code></pre>
<pre class="language-typescript"><code class="language-typescript">// @flow

const obj1: Object = {} // ok

const obj2: Object = {
    a: 'string',
    b: true,
    c: 123,
    d: null,
} // ok</code></pre>
<p>Other dangerous types can be <code>Function</code> or <code>{}</code>. See <a href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/ban-types.md">ban-types</a> eslint rule from typescript-eslint-plugin.</p>
<h2><a href="#named-arguments--keys">Named arguments / keys</a></h2>
<p>In Flow one does not have to specify argument or object key names in order to provide a type annotation.</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

const func
    : string => void
    = (arg) => console.log(arg)

const obj
    : {[string]: number}
    = {foo: 1}</code></pre>
<p>Typescript marks this code with errors forcing users to provide a more explanatory names that will be used in type hints</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

const func
    : (arg: string) => void
    = (arg) => console.log(arg)

const obj
    : {[key: string]: number}
    = {foo: 1}</code></pre>
<img width="372" alt="Screen Shot 2021-03-28 at 5 00 30 PM" src="https://user-images.githubusercontent.com/5817809/112754957-3d15fa80-8fe7-11eb-9bc4-dad86c5f149b.png">

<h2><a href="#jsdoc-support">JSDoc support</a></h2>
<p>Typescript has support for <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html">JSDoc comments</a> and will show you them on type hits.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

/**
 * Does cool stuff
 *
 * @example
 *
 * `foo('hey', 'you') => 'hey, you'`
 */
type Foo = (start: string, end: string) => string</code></pre>
<p>Preview:</p>
<p><img src="https://user-images.githubusercontent.com/5817809/112764820-f2aa7300-9012-11eb-9b34-277e5dc51311.png" alt="Screen Shot 2021-03-28 at 10 12 19 PM"></p>
<p>✅ It&#39;s a good idea to always include comments for utility functions.</p>
<h2><a href="#intersection--spread-object-types">Intersection / spread object types</a></h2>
<p>In flow you can &quot;merge&quot; object types by using intersection or by spreading types. Spreads create an inexact object type therefore if we need an exact one we have to specify it with <code>{||}</code> syntax.</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

type A = {a: string}
type B = {b: number}

type AB_1 = A &amp; B // {a: string, b: number}
type AB_2 = {...A, ...B} // {a: string, b: number}

type AB = {a: boolean, b: boolean}

type AB_3 = {...A, ...B, ...AB} // {a: boolean, b: boolean}

type AB_3_strict = {|...A, ...B, ...AB|} // {|a: boolean, b: boolean|}</code></pre>
<p>In typescript we cannot spread object types though the experience is pretty similar.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type A = {a: string}
type B = {b: number}

type AB_1 = A &amp; B // {a: string, b: number}

type AB = {a: boolean, b: boolean}

type AB_3 = A &amp; B &amp; AB // never 😳

type FML = string &amp; number // never</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

interface A {
    a: string
}

interface B extends A {
//        ^ error
    a: number
}
// Interface 'B' incorrectly extends interface 'A'.
//  Types of property 'a' are incompatible.
//    Type 'number' is not assignable to type 'string'.</code></pre>
<p>When intersecting object with the same key TS attemps to find the common type between the value types under the common key.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type Strs = 'A' | 'B' | 'C'
type Str = 'A'

type IntStr = Strs &amp; Str

const a: IntStr = 'A' // ok
const b: IntStr = 'B' // error
const c: IntStr = 'C' // error

// ===============

type A1 = {prop: 'A' | 'B' | 'C'}
type A2 = {prop: 'A'}

type Intersection = A1 &amp; A2

const a: Intersection = {prop: 'A'} // ok
const b: Intersection = {prop: 'B'} // error
const c: Intersection = {prop: 'C'} // error</code></pre>
<p>To get a similar result as object spreads in flow we can add a utility type like <code>ShallowMerge</code></p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type A = {a: string}
type B = {b: number}

type AB_1 = A &amp; B // {a: string, b: number}

type AB = {a: boolean, b: boolean}
type ShallowMerge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>A</span> <span class="token attr-name">extends</span> <span class="token attr-name">object,</span> <span class="token attr-name">B</span> <span class="token attr-name">extends</span> <span class="token attr-name">object</span><span class="token punctuation">></span></span> = Omit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>A,</span> <span class="token attr-name">keyof</span> <span class="token attr-name">B</span><span class="token punctuation">></span></span> &amp; B

type AB_merged = ShallowMerge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>A,</span> <span class="token attr-name">AB</span><span class="token punctuation">></span></span> // {a: boolean, b: boolean}</code></pre>
<h2><a href="#type-casting">Type casting</a></h2>
<pre class="language-typescript"><code class="language-typescript">// @flow

const str = 'foobar'

str // string

const func = ((str: any): Function)

func() // ok</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

const str = 'foobar'

str // string

const func = (str as any) as Function

func() // ok</code></pre>
<p>This feature should be avoided when possible.</p>
<h2>Difference between <code>void</code> &amp; <code>undefined</code> in typescript</h2>
<p>In flow one uses <code>void</code> at all times. In typescript you use <code>undefined</code> where it is an expected value to be used and <code>void</code> otherwise. For example for a function which result should not be used.</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

const func
    : string => void
    = (arg) => console.log(arg)

if (func()) { // ok
}</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

const func
    : (arg: string) => void
    = (arg) => console.log(arg)

if (func()) { // error: An expression of type 'void' cannot be tested for truthiness.(1345)
}

const bar: undefined = void 0

if (bar) { // ok
}</code></pre>
<h2>Typed <code>this</code></h2>
<p>In flow you cannot specify the type for <code>this</code> for functions</p>
<p>In typescript you can specify the type by naming the first argument type <code>this</code></p>
<pre class="language-typescript"><code class="language-typescript">// typescript in
function HtmlPage(this: {redirect: (url: string) => void}, params: Record<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string,</span> <span class="token attr-name">string</span><span class="token punctuation">></span></span>) {
    if (typeof params.id !== 'string') {
        this.redirect('/login')
    }

    // logic
}

// javascript out
function HtmlPage(params) {
    if (typeof params.id !== 'string') {
        this.redirect('/login')
    }

    // logic
}</code></pre>
<h2><code>any</code> vs <code>mixed</code> in flow or <code>any</code> vs <code>unknown</code> in typescript</h2>
<p><code>any</code> is a hack in both type systems ⚠️. It is both a subtype and a supertype of every type. This is why you can use it in any way</p>
<pre class="language-typescript"><code class="language-typescript">function foo(arg: any) {
    arg(null)

    arg(1, 2, 3)

    arg.toFixed(5)

    arg.map(console.log)

    arg.has(42)

    arg.then(someFunc)
} // ok</code></pre>
<p>There is a type to represent an unknown value in both type systems, it typescript it is called <code>unknown</code> and in flow we have <code>mixed</code></p>
<pre class="language-typescript"><code class="language-typescript">// typescript

function foo(arg: unknown) {
    if (typeof arg === 'function') {
        arg(null)

        arg(1, 2, 3)
    }

    if (typeof arg === 'number') {
        arg.toFixed(5)
    }

    if (Array.isArray(arg)) {
        arg.map(console.log)
    }

    if (arg instanceof Set) {
        arg.has(42)
    }

    if (arg instanceof Promise) {
        arg.then(someFunc)
    }
} // ok</code></pre>
<p>⚠️ Avoid using <code>any</code> at all costs</p>
<h2><a href="#type-narrowing-aka-type-refinement">Type narrowing a.k.a. type refinement</a></h2>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">typescript</a></p>
<p><a href="https://flow.org/en/docs/lang/refinements/">flow</a></p>
<p>Kinds of guards:</p>
<ul>
<li><code>typeof</code> guards can narrow the type to string/number/biging/boolean/symbol/undefined/object/function</li>
<li>Truthiness narrowing via <code>&amp;&amp;</code>/<code>||</code>/<code>if</code>/<code>!</code>, misses <code>0</code>/<code>NaN</code>/<code>&#39;&#39;</code>/<code>0n</code>/<code>null</code>/<code>undefined</code></li>
<li>Equality narrowing <code>===</code>/<code>==</code>/<code>!==</code>/<code>!=</code></li>
<li><code>instanceof</code> narrowing</li>
</ul>
<pre class="language-typescript"><code class="language-typescript">// typescript
function foo(arg: string) {
    if (['A', 'B'].includes(arg)) {
        arg // string
    }

    if (arg === 'A' || arg === 'B') {
        arg // 'A' | 'B'
    }
}</code></pre>
<h2><a href="#type-guards">Type guards</a></h2>
<p>Both <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">typescript</a> and <a href="https://flow.org/en/docs/types/functions/#toc-predicate-functions">flow</a> have type guards.</p>
<p>Example: let&#39;s check that the given nullable variable is not in fact <code>null</code></p>
<pre class="language-typescript"><code class="language-typescript">// @flow

function isNonNullable(arg: string | null | void): boolean %checks {
    return arg != null
}

function foo(arg: ?string) {
    if (isNonNullable(arg)) {
        arg // string
    }
}</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

function isNonNullable(arg: string | null | undefined): arg is string {
    return arg != null
    // return typeof arg === 'string'
}

function foo(arg: string | null | undefined) {
    if (isNonNullable(arg)) {
        arg // string
    }
}</code></pre>
<h3><a href="#handling-sloppy-cases">Handling sloppy cases</a></h3>
<p>Flow forces you to check the type withing your type predicate</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

function isNonNullable(arg: string | null | void): boolean %checks {
    return true // &lt;-- sloppy check
}

function foo(arg: ?string) {
    if (isNonNullable(arg)) {
        arg // ?string
        //     ^ note the `?`
    }
}</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

function isNonNullable(arg: string | null | undefined): arg is string {
    return true
}

function foo(arg: string | null | undefined) {
    if (isNonNullable(arg)) {
        arg // string
        //     ^^^^^^ still works 😳
    }
}</code></pre>
<p>⚠️ Pay close attention to type predicates, typescript won&#39;t guard you from writing sloppy checks</p>
<h2><a href="#type-assertion">Type assertion</a></h2>
<h3><a href="#non-null-assertion-operator">Non-null assertion operator</a></h3>
<p>Unlike flow typescript expands javascript syntax. An example can be <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator">non-null assertion operator</a>. Its usage does not affect the runtime, ie it can be dangerous ⚠️</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

declare function foo(): null | {prop: string}

foo().prop // error

foo()!.prop // ok
//   ^ this

// transpiled javascript
foo().prop</code></pre>
<h3><a href="#const-assertions">Const assertions</a></h3>
<p><code>const foo = {} as const</code></p>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">v3.4</a></p>
<p>This feature allows you to disable type widening when declaring values in typescript.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

const plainObj = {a: 1, b: 'foo'}

plainObj // {a: number; b: string}

const constObj = {a: 1, b: 'foo'} as const

constObj // {readonly a: 1; readonly b: 'foo'}</code></pre>
<p>This is <strong>not</strong> the same as using <code>Object.freeze</code></p>
<pre class="language-typescript"><code class="language-typescript">// typescript
const constObj = {a: 1, b: 'foo', c: {d: 'bar'}} as const

constObj // {readonly a: 1, readonly b: 'foo', readonly c: {readonly d: 'bar}}

// @ts-expect-error Cannot assign to 'd' because it is a read-only property.
constObj.c.d = 'foo'

// ------------------------

const frozen = Object.freeze({a: 1, b: 'foo', c: {d: 'bar'}})

frozen // Readonly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">{a:</span></span> <span class="token attr-name">number;</span> <span class="token attr-name"><span class="token namespace">b:</span></span> <span class="token attr-name">string;</span> <span class="token attr-name"><span class="token namespace">c:</span></span> <span class="token attr-name"><span class="token namespace">{d:</span></span> <span class="token attr-name">string}}</span><span class="token punctuation">></span></span>

// @ts-expect-error Cannot assign to 'b' because it is a read-only property.
frozen.b = 'foo 2'

// no error since `Readonly` is not deep
frozen.c.d = 'foo'</code></pre>
<p>The key things that happen when const assertions are being used are:</p>
<ul>
<li>no literal types in that expression should be widened (e.g. no going from <code>&quot;hello&quot;</code> to <code>string</code>)</li>
<li>object literals get <code>readonly</code> properties</li>
<li>array literals become <code>readonly</code> tuples</li>
</ul>
<h3><a href="#assert-functions">Assert functions</a></h3>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions">v3.7</a></p>
<p>Assert functions are similar to <code>type guards</code> with the only difference that the function throws instead of returning a falsy value. This works on par with nodejs <a href="https://nodejs.org/docs/latest/api/assert.html"><code>assert</code></a> module.</p>
<p>Using assert function you can validate an input ie</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

function plainAssertion(arg: unknown): asserts arg {
    if (!arg) {
        throw new Error(`arg is expected to be truthy, got "${arg}"`)
    }
}

function foo(input: boolean, item: string | null) {
    input // boolean
    plainAssertion(input)
    input // true

    item // string | null
    plainAssertion(item)
    item // string
}</code></pre>
<p>Alternatively you can narrow down the type to be more specific. This is when the similarity with <code>type guards</code> shows.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type Item = {
    type: 'item';
}

function assertItem(arg: unknown): asserts arg is Item {
    if (isObject(arg) &amp;&amp; 'type' in arg &amp;&amp; arg.type === 'item') {
        return arg
    }

    throw new Error(`arg is expected to be an Item, got "${arg}"`)
}

function getItemById(state: State, id: string): Item | undefined {
    const item = state.collections.items[id]

    item // undefined | Item

    return item
}

function getItemByIdSafe(state: State, id: string): Item {
    const item = state.collections.items[id]

    item // undefined | Item

    assertItem(item)

    item // Item

    return item
}</code></pre>
<p>The same as plain type guards you don&#39;t have to validate the entire object scheme to guard other values. In other words the below code is OK for typescript standards ⚠️</p>
<pre class="language-typescript"><code class="language-typescript">function assertWhatever(arg: unknown): asserts arg is Item {
    return undefined
}

function foo(arg: unknown) {
    arg // unknown

    assertWhatever(arg)

    arg // Item
}</code></pre>
<!-- intermediate diff -->

<h2><a href="#type-narrowing-invalidation">Type narrowing invalidation</a></h2>
<p>Flow has so called <a href="https://flow.org/en/docs/lang/refinements/#toc-refinement-invalidations">refinement invalidations</a></p>
<pre class="language-typescript"><code class="language-typescript">// @flow
function func(value: { prop?: string }) {
    if (value.prop) {
        value.prop // string
        otherMethod()
        value.prop // string | void
        // $ExpectError
        value.prop.charAt(0)
    }
}</code></pre>
<p>Once we checked for <code>value.prop</code> value, the refined type is string. However if we call something within the current scope. Flow invalidated the refinement since it is possible that the object <code>value</code> was mutated within <code>otherMethod</code>. To avoid the invalidation one can extract the primitive value into its own variable ie</p>
<pre class="language-typescript"><code class="language-typescript">// @flow
function func(value: { prop?: string }) {
    if (value.prop) {
        const {prop} = value
        prop // string
        otherMethod()
        prop // string
        value.prop // void | string
        prop.charAt(0)
    }
}</code></pre>
<p>Typescript is missing this feature on purpose since its <a href="https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals">goals</a> aim at being a complete type system rather than sound.</p>
<h2><a href="#strict-vs-loose-objects">Strict vs loose objects</a></h2>
<p>Flow has syntax to specify whether the objects has a specified set of fields and nothing more aka strict or non extensible or is loose aka can have other non specified fields</p>
<pre class="language-typescript"><code class="language-typescript">// @flow
type L = {a: number}
const loose_1: L = {a: 1} // ok
const loose_2: L = {a: 1, b: 'str', c: true} // ok

type S = {|a: number|}
const strict_1: L = {a: 1} // ok
const strict_2: L = {a: 1, b: 'str', c: true} // error</code></pre>
<p>In typescript objects are &quot;strict&quot; by default</p>
<pre class="language-typescript"><code class="language-typescript">// typescript
type O = {a: number}
const obj_1: O = {a: 1} // ok
const obj_2: O = {a: 1, b: 'str', c: true} // error</code></pre>
<p>However this does not always guarantee that typescript wont raise errors about unwanted fields.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type A = {a: number}

declare function takesA(arg: A): void

takesA({a: 1}) // ok
takesA({a: 1, b: 'foo'}) // error

// -----------------

const x = {a: 1, b: 'foo'}
takesA(x) // ok 😳</code></pre>
<p>According to typescript this is a valid code. <a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAggQlAvFA3gQwFxQEYHtcA2EaAdgDQ5Z6HEkC+AUKJFAMJKoDGV+RpjzaAFUAcgEkA8iI7woAHzYMGnXCQDOwKLmwArLKMnTkKbFmAAnAK4QK3KBet0gA">playground</a></p>
<pre class="language-typescript"><code class="language-typescript">type AB = {a: boolean, b: boolean}
type C = {c: boolean}
type UNION = AB | C

const obj: UNION = {b: true, c: true} // ok 😳</code></pre>
<h2><a href="#tuple-bugs">Tuple Bugs</a></h2>
<p>Typescript <a href="https://github.com/microsoft/TypeScript/issues/6594#issuecomment-174315415">issue</a> for context</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

const a: number[][] = [[1,2], [3,4]]
const b: number[] = [1,2]
const c: number[][] = a.concat(b) // no error

c // typescript type `number[][]`
c // runtime value `[[1,2], [3,4], 1, 2]`</code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgLhmArgWwEYFMBOBtAXUJgF4Y88BGAGgCYDryBmagFgIIChRJYMlUmXMTJU6XHtBjAB6bPiIFS8AHQ9gcKAAoMASk7cYAeiMwoATwAOWCMBwBLS7AvWYAA0HzChN4ZMwcFDAoezQsGAA3OAAbFHC3Chp6RjwWdkYaGHo3IA">ts playground</a>
<a href="https://flow.org/try/#0MYewdgzgLgBAhgLhmArgWwEYFMBOBtAXUJgF4Y88BGAGgCYDryBmagFgIIChRJYMlUmXMTJU6XHtBjAB6bPiIFS8AHQ9gcKAAoMASk7cYAeiMwoATwAOWCMBwBLS7AvWYAA0HzChN4ZMwcFDAoezQsGAA3OAAbFHC3Chp6RjwWdkYaGHo3IA">flow raises an error as expected</a></p>
<h2><a href="#enums">Enums</a></h2>
<p>see <a href="https://www.typescriptlang.org/play?#code/KYOwrgtgBACgNgQwJYigbwFBW1A9iYAGixwBcB3XYnKUgCwCdhgMBfDDUSKAOQQmAATdCWz5gUALxQA5OJnUylKbIq4Fo2o2YqZ9JsBlsOAY3wBnUlC7QAwhauYa43fMXY1utRpr6d0vW1DYwxSAE8ABwkAUXAIAGlgMPMVAGsk3AAzWkjgLNhEFABuKAB6UqgAInFKqAAfKrVahsq-YEqOTLAQE1IkfChM3FwACgjCkAAuAuQQQigQfiFpvgFBeZMzEEtp+23SAEoRGiRssYmpSQD5I7RWMorgBgZcBmn6CXColJl4WZkoAgQMIZJYGCgAOYAugIABuEhAuDw8IYiAiADoOCczuNZpdpH8UOjxLdNDRcSgHjMieJNOxNKcoCNFmt8bwloJiQRSTQaCyhFTVkIuSwaPTsUzNg42XtLCKebzsFL9lTZaQRXSQkNRnICApVJR9YEDDIjuVrM9Xu9crJqgRKgCkClEVYEOZzEgIYsAEZwT5IiIIBhLUhPPDZL4SX4TIwYbUjQkgEXzIWctTzNXotoHIA">play</a></p>
<pre class="language-typescript"><code class="language-typescript">enum Plain {
    one,
    two,
    three
}

enum Named {
    one = 'one',
    two = 'two',
    three = 'three'
}

const enum Const {
    one = 'one',
    two = 'two',
    three = 'three'
}

type EnumKeys = keyof typeof Plain; // "one" | "two" | "three"

function foo(plain: Plain, named: Named, cconst: Const) {
    if (plain === 'one') {} // error: the types 'Plain' and 'string' have no overlap.

    if (plain === Plain.one) {
        plain // Plain.one
    }

    if (named === Named.one) {
        named // Named.one
    }

    if (cconst === Const.one) {
        cconst // Const.one
    }
}

foo('one', 'two', 'three') // error: type '"one"' is not assignable to parameter of type 'Plain'

foo(Plain.one, Named.two, Const.three)</code></pre>
<h2><a href="#opaque-types">Opaque types</a></h2>
<p>Flow has support for <code>opaque</code> type aliases. They are the same as regular type aliases but do not allow access to their underlying type outside of the file in which they are defined.</p>
<pre class="language-typescript"><code class="language-typescript">// @flow

// a.js

opaque type UserId = string

type User = {id: UserId, name: string}

declare function getUserById(id: UserId): User | void

// b.js (has to be a different file)

getUserById('1234') // error

const someId: UserId = '4321'

getUserById(someId) // ok</code></pre>
<p>Typescript does not have such feature since it is not nominal yet you can get somewhat similar result</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type Brand<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>K,</span> <span class="token attr-name">T</span><span class="token punctuation">></span></span> = K &amp; { __brand: T }

type UserId = Brand<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string,</span> <span class="token attr-name">'userId'</span><span class="token punctuation">></span></span>
type User = {id: UserId, name: string}

declare function getUserById(id: UserId): User | void

getUserById('1234') // error

const someId: UserId = '4321'
//    ^^^^^^ Type 'string' is not assignable to type '{ __brand: "userId"; }'.

const castedId = '4321' as UserId // have to cast explicitly

getUserById(castedId) // ok</code></pre>
<p>This has an issue since these &quot;branded&quot; types cannot be used to index collections.</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type UserCollection = Record<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>UserId,</span> <span class="token attr-name">User</span><span class="token punctuation">></span></span>

const userCollection: UserCollection = {}

let a = userCollection[castedId]
//      ^^^^^^^^^^^^^^^^^^^^^^^^ Element implicitly has an 'any' type because expression of
//                               type 'UserId' can't be used to index type 'UserCollection'</code></pre>
<h2><a href="#mapped-types">Mapped types</a></h2>
<p>For the typical <code>$ObjMap</code> &amp; <code>$ObjMapi</code> enjoyers, typescript cannot call functions at a type level therefore they have a syntax for mapping over a union</p>
<pre class="language-typescript"><code class="language-typescript">// typescript
type Union = 'A' | 'B' | 'C'

type Obj = {
    [K in Union]: K;
}

// typeof Obj -> {A: 'A'; B: 'B'; C: 'C'}</code></pre>
<h2><a href="#built-in-utils">Built-in utils</a></h2>
<ul>
<li>Partial</li>
<li>Required</li>
<li>Readonly</li>
<li>Record</li>
<li>Pick</li>
<li>Omit</li>
<li>Exclude</li>
<li>Extract</li>
<li>NonNullable</li>
<li>Parameters</li>
<li>ConstructorParameters</li>
<li>ReturnType</li>
<li>InstanceType</li>
<li>ThisParameterType</li>
<li>OmitThisParameter</li>
<li>ThisType</li>
</ul>
<pre class="language-typescript"><code class="language-typescript">// typescript

type Record<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>K</span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span> <span class="token attr-name">|</span> <span class="token attr-name">number</span> <span class="token attr-name">|</span> <span class="token attr-name">symbol,</span> <span class="token attr-name">T</span><span class="token punctuation">></span></span> = {
    [P in K]: T;
}

const userCollection: Record<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>UserId,</span> <span class="token attr-name">User</span><span class="token punctuation">></span></span> = {
    '1': {
        id: '1',
        name: 'John Doe',
    }
}

// ======================

type Props = {
    active: boolean;
    className: string;
}

declare function MyComponent(props: Props): ReactNode

type GetComponentProps&lt;T extends (props: any) => ReactNode> = Parameters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span>[0]

type CompProps = GetComponentProps<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeof</span> <span class="token attr-name">MyComponent</span><span class="token punctuation">></span></span> // Props</code></pre>
<h2><a href="#generics-syntax">Generics syntax</a></h2>
<h3><a href="#generic-types">generic types</a></h3>
<pre class="language-typescript"><code class="language-typescript">// @flow

type ToTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = [T]

type ToStringTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name">string</span><span class="token punctuation">></span></span> = [T]

type ToDefaultToStringTuple&lt;T = 'B'> = [T]

type ToTogetherTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name">string</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>C<span class="token punctuation">'</span></span><span class="token punctuation">></span></span> = [T]

type A = ToStringTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>'A'</span><span class="token punctuation">></span></span>

type B = ToDefaultToStringTuple&lt;>

type C = ToTogetherTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>

const a: A = ['A']

const b: B = ['B']

const c: C = ['F']</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

type ToTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = [T]

type ToStringTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span><span class="token punctuation">></span></span> = [T]

type ToDefaultToStringTuple&lt;T = 'B'> = [T]

type ToTogetherTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>C<span class="token punctuation">'</span></span><span class="token punctuation">></span></span> = [T]

type A = ToStringTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>'A'</span><span class="token punctuation">></span></span>

type _B = ToDefaultToStringTuple&lt;>
//                              ^^ error: cannot be empty

type B = ToDefaultToStringTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>

type C = ToTogetherTuple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>

const a: A = ['A']

const b: B = ['B']

const c: C = ['F']</code></pre>
<h3><a href="#generic-functions">generic functions</a></h3>
<pre class="language-typescript"><code class="language-typescript">// @flow

declare function foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span>(arg: T): {foo: T}

declare function bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name">string</span><span class="token punctuation">></span></span>(arg: T): {bar: T}

declare function baz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name">string</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>(arg: T): {baz: T}</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

declare function foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span>(arg: T): {foo: T}

declare function bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span><span class="token punctuation">></span></span>(arg: T): {bar: T}

declare function baz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>(arg: T): {baz: T}</code></pre>
<hr>
<pre class="language-typescript"><code class="language-typescript">// @flow

declare function easy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name"><span class="token namespace">{a:</span></span> <span class="token attr-name">string}</span><span class="token punctuation">></span></span>(arg: T): T

const aaa = easy({a: '', b: 42}) // ok

aaa // {|a: string, b: number|}

declare function strict<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name"><span class="token namespace">{|a:</span></span> <span class="token attr-name">string|}</span><span class="token punctuation">></span></span>(arg: T): T

const bbb = strict({a: '', b: 42}) // error

const ccc = strict({a: ''}) // ok

ccc // {|a: string|}</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

declare function func<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name"><span class="token namespace">{a:</span></span> <span class="token attr-name">string}</span><span class="token punctuation">></span></span>(arg: T): T

const qlwerk = func({a: '', b: 42}) // ok

qlwerk // {a: string, b: number}</code></pre>
<h2><a href="#generic-type-variance">Generic type variance</a></h2>
<pre class="language-typescript"><code class="language-typescript">// @flow

type A = {|a: string|}

type AB = {|a: string, b: string|}

type ABC = {|a: string, b: string, c: string|}

declare function takesAB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">T:</span></span> <span class="token attr-name">AB</span><span class="token punctuation">></span></span>(arg: T): void

declare var a__: A
declare var ab_: AB
declare var abc: ABC

takesAB(a__) // error

takesAB(ab_) // ok

takesAB(abc) // error</code></pre>
<p>⚠️ Typescript generics are covariant and there&#39;s nothing one can do about it</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

type A = {a: string}

type AB = {a: string, b: string}

type ABC = {a: string, b: string, c: string}

declare function takesAB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">extends</span> <span class="token attr-name">AB</span><span class="token punctuation">></span></span>(arg: T): void

declare var a__: A
declare var ab_: AB
declare var abc: ABC

takesAB(a__) // error

takesAB(ab_) // ok

takesAB(abc) // ok</code></pre>
<p>While in flow generics are invariant by default, but one <a href="https://flow.org/en/docs/types/generics/#toc-variance-sigils">can specify</a> if they want it to behave covariant or contravariant.</p>
<h2><a href="#type-variance">Type variance</a></h2>
<p><strong>Flow</strong>:</p>
<ul>
<li>see <a href="https://flow.org/en/docs/lang/variance/">flow docs</a></li>
<li>allows you to make types covariant or contravariant <a href="https://flow.org/en/docs/types/generics/#toc-variance-sigils">docs</a></li>
</ul>
<p><strong>Typescript</strong></p>
<pre class="language-typescript"><code class="language-typescript">// typescript

class Noun {}
class City extends Noun {}
class SanFrancisco extends City {}

declare function method(value: City): void

method(new Noun())         // ok
method(new City())         // ok
method(new SanFrancisco()) // ok

// stucture check, {} === {}
method({}) // proof

method([]) // 😳

method('foo') // still an object

method(null) // err</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

class Noun {
    count() { }
}
class City extends Noun {}
class SanFrancisco extends City {}

method(new Noun()) // ok

method(new City()) // ok

method(new SanFrancisco()) // ok

method({}) // error

method({ count() {} }) // ok
method(Object.assign([], { count() {} })) // ok</code></pre>
<p>covariant like check</p>
<pre class="language-typescript"><code class="language-typescript">// typescript

class Noun {
    constructor(public name: string) {}
}
class City extends Noun {
    constructor(public name: string, public geo: number) {
        super(name)
    }
}
class SanFrancisco extends City {
    constructor(public name: string, public geo: number, public whatever: string) {
        super(name, geo)
    }
}

declare function method(value: City): void

method(new Noun('moscow'))                 // error
method(new City('moscow', 42))             // ok
method(new SanFrancisco('moscow', 42, '')) // ok</code></pre>
<h3><a href="#conditional-types">Conditional types</a></h3>
<pre class="language-typescript"><code class="language-typescript">// typescript

type IsString<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = T extends string ? true : false

type A = IsString<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span> // true

type B = IsString<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>{}</span><span class="token punctuation">></span></span> // false</code></pre>
<h3><a href="#infer">Infer</a></h3>
<pre class="language-typescript"><code class="language-typescript">// typescript

type ElementType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>A</span><span class="token punctuation">></span></span> = A extends Array<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>infer</span> <span class="token attr-name">U</span><span class="token punctuation">></span></span> ? U : never

type A = ElementType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span> // never

type B = ElementType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>['A',</span> <span class="token attr-name">'B']</span><span class="token punctuation">></span></span> // 'A' | 'B'</code></pre>
<pre class="language-typescript"><code class="language-typescript">// typescript

declare function add(a: string, b: string): string
declare function add(a: number, b: number): number
declare function add(a: string | number, b: string | number): string | number

type SillyResult = ReturnType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeof</span> <span class="token attr-name">add</span><span class="token punctuation">></span></span> // string | number

type SmartReturnType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>F,</span> <span class="token attr-name">A</span> <span class="token attr-name">extends</span> <span class="token attr-name">Array&lt;any</span><span class="token punctuation">></span></span>> = F extends (...args: A) => infer R ? R : never

type NotThatSilly = SmartReturnType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeof</span> <span class="token attr-name">add,</span> <span class="token attr-name">[string,</span> <span class="token attr-name">string]</span><span class="token punctuation">></span></span> // string | number

type AtLeastWeHaveThis = SmartReturnType<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeof</span> <span class="token attr-name">add,</span> <span class="token attr-name">[string,</span> <span class="token attr-name">number]</span><span class="token punctuation">></span></span> // never</code></pre>
<pre class="language-typescript"><code class="language-typescript">// @flow

declare function add(a: string, b: string): string
declare function add(a: number, b: number): number
declare function add(a: string | number, b: string | number): string | number

type Returns = $Call<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeof</span> <span class="token attr-name">add,</span> <span class="token attr-name">string,</span> <span class="token attr-name">string</span><span class="token punctuation">></span></span> // string</code></pre>

    </article>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Typescript assertions</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.6.1/github-markdown.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            box-sizing: border-box;
            margin: 0;
        }

        .markdown-body {
            min-width: 200px;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #0d1117;
            }
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --fgColor-default: #e6edf3;
            }
        }
        @media (prefers-color-scheme: light) {
            :root {
                --fgColor-default: #1f2328;
            }
        }

        header {
            display: flex;
            gap: 24px;
            border-bottom: 1px solid #e1e4e8;
            padding: 16px 24px;
        }
        header a {
            color: var(--fgColor-default);
        }
        .markdown-body h1 > a,
        .markdown-body h2 > a,
        .markdown-body h3 > a,
        .markdown-body h4 > a,
        .markdown-body h5 > a,
        .markdown-body h6 > a {
            color: var(--fgColor-default);
            text-decoration: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
</head>

<body>
    <header>
        <a href="/webdevandstuff">Web dev and stuff</a>
        <a href="https://github.com/antonk52" target="_blank">GitHub</a>
        <a href="https://twitter.com/antonk52" target="_blank">Twitter</a>
    </header>

    <article class="markdown-body">
        <h1>Typescript assertions</h1>
        
        <p>The below implies that you have already read the <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions">type assertions</a> section in typescript documentation.</p>
<h2 id="list-of-content"><a href="#list-of-content">List of content</a></h2>
<ul>
<li><a href="#as-cast-operator"><code>as</code> cast operator</a></li>
<li><a href="#const-assertions">Const assertions</a></li>
<li><a href="#assert-functions">Assert functions</a></li>
<li><a href="#key-remapping-in-mapped-types">Key remapping in mapped types</a></li>
</ul>
<h2 id="as-cast-operator"><code>as</code> cast operator</h2>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#new-tsx-file-extension-and-as-operator">v1.6</a></p>
<p>This operator allows you to explicitly cast the type for a value of a different type without typescript raising an error. This is a dangerous a foot gun like feature that should be used with care and consciously. To quote the typescript docs this is a way to tell the compiler <code>trust me, I know what Iâ€™m doing.</code></p>
<p>This feature has two ways to use it.</p>
<pre><code class="language-typescript">const a = notFoo as Foo;
/**
 * The same thing
 * but wont work for `.tsx` files
 */
const b = &lt;Foo&gt;notFoo;

/**
 * now both `a` and `b` are of type `Foo`
 */
</code></pre>
<h2 id="const-assertions-1"><a href="#const-assertions">Const assertions</a></h2>
<p><code>const foo = {} as const</code></p>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">v3.4</a></p>
<p>This feature allows you to disable type widening when declaring values in typescript.</p>
<pre><code class="language-typescript">const plainObj = {a: 1, b: &#39;foo&#39;};

plainObj; // {a: number; b: string}

const constObj = {a: 1, b: &#39;foo&#39;} as const;
const constObjAlt = &lt;const&gt;{a: 1, b: &#39;foo&#39;};

constObj; // {readonly a: 1; readonly b: &#39;foo&#39;}
</code></pre>
<p>This is <strong>not</strong> the same as using <code>Object.freeze</code></p>
<pre><code class="language-typescript">const constObj = {a: 1, b: &#39;foo&#39;, c: {d: &#39;bar&#39;}} as const;

constObj; // {readonly a: 1, readonly b: &#39;foo&#39;, readonly c: {readonly d: &#39;bar}}

// @ts-expect-error Cannot assign to &#39;d&#39; because it is a read-only property.
constObj.c.d = &#39;foo&#39;

const frozen = Object.freeze({a: 1, b: &#39;foo&#39;, c: {d: &#39;bar&#39;}})

frozen; // Readonly&lt;{a: number; b: string; c: {d: string}}&gt;

// @ts-expect-error Cannot assign to &#39;b&#39; because it is a read-only property.
frozen.b = &#39;foo 2&#39;

// no error since `Readonly` is not deep
frozen.c.d = &#39;foo&#39;
</code></pre>
<p>The key things that happen when const assertions are being used are:</p>
<ul>
<li>no literal types in that expression should be widened (e.g. no going from <code>&quot;hello&quot;</code> to <code>string</code>)</li>
<li>object literals get <code>readonly</code> properties</li>
<li>array literals become <code>readonly</code> tuples</li>
</ul>
<h2 id="assert-functions-1"><a href="#assert-functions">Assert functions</a></h2>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions">v3.7</a></p>
<p>Assert functions are similar to <code>type guards</code> with the only difference that the function throws instead of returning a falsy value. This works on par with nodejs <a href="https://nodejs.org/docs/latest/api/assert.html"><code>assert</code></a> module.</p>
<p>Using assert function you can validate an input ie</p>
<pre><code class="language-typescript">function plainAssertion(arg: unknown): asserts arg {
    if (!arg) {
        throw new Error(`arg is expected to be truthy, got &quot;${arg}&quot;`);
    }
}

function foo(input: boolean, item: string | null) {
    input; // boolean
    plainAssertion(input);
    input; // true

    item; // string | null
    plainAssertion(item);
    item; // string
}
</code></pre>
<p>Alternatively you can narrow down the type to be more specific. This is when the similarity with <code>type guards</code> shows.</p>
<pre><code class="language-typescript">function specificAssertion(arg: unknown): asserts arg is string {
    if (typeof arg !== &#39;string&#39;) {
        throw new Error(`arg is expected to be string, got &quot;${arg}&quot;`)
    }
}

function bar(input: string | null) {
    input; // string | null
    specificAssertion(input);
    input; // string
}
</code></pre>
<h2 id="key-remapping-in-mapped-types"><a href="#key-remapping-in-mapped-types">Key remapping in mapped types</a></h2>
<p>ie <code>{[K in keyof T as Foo]: T[K]}</code></p>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">v4.1</a></p>
<p>Reminder of mapped type syntax in typescript</p>
<pre><code class="language-typescript">type Inlined = {
    [key in &#39;a&#39; | &#39;b&#39; | &#39;c&#39;]: string
};

type Keys = &#39;a&#39; | &#39;b&#39; | &#39;c&#39;;
type Aliased = {
    [key in Keys]: string
};

/**
 * both `Inlined` and `Aliased` have the type
 * `{a: string; b: string; c: string}`
 */
</code></pre>
<p>Even though the example in the typescript docs present this feature to be useful in many cases when working with object keys. There are times when there is no need for it.</p>
<p>From the typescript docs:</p>
<pre><code class="language-typescript">// Remove the &#39;kind&#39; property
type RemoveKindField&lt;T&gt; = {
    [K in keyof T as Exclude&lt;K, &quot;kind&quot;&gt;]: T[K]
};

interface Circle {
    kind: &quot;circle&quot;;
    radius: number;
}

type KindlessCircle = RemoveKindField&lt;Circle&gt;;
//   ^ = type KindlessCircle = {
//       radius: number;
//   }
</code></pre>
<p>This gets you the same result</p>
<pre><code class="language-typescript">type RemoveKindField&lt;T&gt; = {
    [K in Exclude&lt;keyof T, &quot;kind&quot;&gt;]: T[K]
};
</code></pre>
<p>Where this feature shines is when you would like to remap the keys using template literal type with having the old key to extract the original value type.</p>
<p>Example from typescript docs:</p>
<pre><code class="language-typescript">type Getters&lt;T&gt; = {
    [K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K]
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters&lt;Person&gt;;
//   ^ = type LazyPerson = {
//       getName: () =&gt; string;
//       getAge: () =&gt; number;
//       getLocation: () =&gt; string;
//   }
</code></pre>

    </article>
</body>
</html>

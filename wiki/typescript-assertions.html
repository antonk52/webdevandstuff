<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Typescript assertions</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.6.1/github-markdown.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            box-sizing: border-box;
            margin: 0;
        }

        .markdown-body {
            min-width: 200px;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #0d1117;
            }
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --fgColor-default: #e6edf3;
            }
        }
        @media (prefers-color-scheme: light) {
            :root {
                --fgColor-default: #1f2328;
            }
        }

        header {
            display: flex;
            gap: 24px;
            border-bottom: 1px solid #e1e4e8;
            padding: 16px 24px;
        }
        header a {
            color: var(--fgColor-default);
        }
        .markdown-body h1 > a,
        .markdown-body h2 > a,
        .markdown-body h3 > a,
        .markdown-body h4 > a,
        .markdown-body h5 > a,
        .markdown-body h6 > a {
            color: var(--fgColor-default);
            text-decoration: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>

<body>
    <header>
        <a href="/webdevandstuff">Web dev and stuff</a>
        <a href="https://github.com/antonk52" target="_blank">GitHub</a>
        <a href="https://twitter.com/antonk52" target="_blank">Twitter</a>
    </header>

    <article class="markdown-body">
        <h1>Typescript assertions</h1>
        
        <p>The below implies that you have already read the <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions">type assertions</a> section in typescript documentation.</p>
<h2><a href="#list-of-content">List of content</a></h2>
<ul>
<li><a href="#as-cast-operator"><code>as</code> cast operator</a></li>
<li><a href="#const-assertions">Const assertions</a></li>
<li><a href="#assert-functions">Assert functions</a></li>
<li><a href="#key-remapping-in-mapped-types">Key remapping in mapped types</a></li>
</ul>
<h2><code>as</code> cast operator</h2>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#new-tsx-file-extension-and-as-operator">v1.6</a></p>
<p>This operator allows you to explicitly cast the type for a value of a different type without typescript raising an error. This is a dangerous a foot gun like feature that should be used with care and consciously. To quote the typescript docs this is a way to tell the compiler <code>trust me, I know what Iâ€™m doing.</code></p>
<p>This feature has two ways to use it.</p>
<pre class="language-typescript"><code class="language-typescript">const a = notFoo as Foo;
/**
 * The same thing
 * but wont work for `.tsx` files
 */
const b = <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Foo</span><span class="token punctuation">></span></span>notFoo;

/**
 * now both `a` and `b` are of type `Foo`
 */</code></pre>
<h2><a href="#const-assertions">Const assertions</a></h2>
<p><code>const foo = {} as const</code></p>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">v3.4</a></p>
<p>This feature allows you to disable type widening when declaring values in typescript.</p>
<pre class="language-typescript"><code class="language-typescript">const plainObj = {a: 1, b: 'foo'};

plainObj; // {a: number; b: string}

const constObj = {a: 1, b: 'foo'} as const;
const constObjAlt = <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>const</span><span class="token punctuation">></span></span>{a: 1, b: 'foo'};

constObj; // {readonly a: 1; readonly b: 'foo'}</code></pre>
<p>This is <strong>not</strong> the same as using <code>Object.freeze</code></p>
<pre class="language-typescript"><code class="language-typescript">const constObj = {a: 1, b: 'foo', c: {d: 'bar'}} as const;

constObj; // {readonly a: 1, readonly b: 'foo', readonly c: {readonly d: 'bar}}

// @ts-expect-error Cannot assign to 'd' because it is a read-only property.
constObj.c.d = 'foo'

const frozen = Object.freeze({a: 1, b: 'foo', c: {d: 'bar'}})

frozen; // Readonly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">{a:</span></span> <span class="token attr-name">number;</span> <span class="token attr-name"><span class="token namespace">b:</span></span> <span class="token attr-name">string;</span> <span class="token attr-name"><span class="token namespace">c:</span></span> <span class="token attr-name"><span class="token namespace">{d:</span></span> <span class="token attr-name">string}}</span><span class="token punctuation">></span></span>

// @ts-expect-error Cannot assign to 'b' because it is a read-only property.
frozen.b = 'foo 2'

// no error since `Readonly` is not deep
frozen.c.d = 'foo'</code></pre>
<p>The key things that happen when const assertions are being used are:</p>
<ul>
<li>no literal types in that expression should be widened (e.g. no going from <code>&quot;hello&quot;</code> to <code>string</code>)</li>
<li>object literals get <code>readonly</code> properties</li>
<li>array literals become <code>readonly</code> tuples</li>
</ul>
<h2><a href="#assert-functions">Assert functions</a></h2>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions">v3.7</a></p>
<p>Assert functions are similar to <code>type guards</code> with the only difference that the function throws instead of returning a falsy value. This works on par with nodejs <a href="https://nodejs.org/docs/latest/api/assert.html"><code>assert</code></a> module.</p>
<p>Using assert function you can validate an input ie</p>
<pre class="language-typescript"><code class="language-typescript">function plainAssertion(arg: unknown): asserts arg {
    if (!arg) {
        throw new Error(`arg is expected to be truthy, got "${arg}"`);
    }
}

function foo(input: boolean, item: string | null) {
    input; // boolean
    plainAssertion(input);
    input; // true

    item; // string | null
    plainAssertion(item);
    item; // string
}</code></pre>
<p>Alternatively you can narrow down the type to be more specific. This is when the similarity with <code>type guards</code> shows.</p>
<pre class="language-typescript"><code class="language-typescript">function specificAssertion(arg: unknown): asserts arg is string {
    if (typeof arg !== 'string') {
        throw new Error(`arg is expected to be string, got "${arg}"`)
    }
}

function bar(input: string | null) {
    input; // string | null
    specificAssertion(input);
    input; // string
}</code></pre>
<h2><a href="#key-remapping-in-mapped-types">Key remapping in mapped types</a></h2>
<p>ie <code>{[K in keyof T as Foo]: T[K]}</code></p>
<p>Added in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">v4.1</a></p>
<p>Reminder of mapped type syntax in typescript</p>
<pre class="language-typescript"><code class="language-typescript">type Inlined = {
    [key in 'a' | 'b' | 'c']: string
};

type Keys = 'a' | 'b' | 'c';
type Aliased = {
    [key in Keys]: string
};

/**
 * both `Inlined` and `Aliased` have the type
 * `{a: string; b: string; c: string}`
 */</code></pre>
<p>Even though the example in the typescript docs present this feature to be useful in many cases when working with object keys. There are times when there is no need for it.</p>
<p>From the typescript docs:</p>
<pre class="language-typescript"><code class="language-typescript">// Remove the 'kind' property
type RemoveKindField<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = {
    [K in keyof T as Exclude<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>K,</span> <span class="token attr-name">"kind"</span><span class="token punctuation">></span></span>]: T[K]
};

interface Circle {
    kind: "circle";
    radius: number;
}

type KindlessCircle = RemoveKindField<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Circle</span><span class="token punctuation">></span></span>;
//   ^ = type KindlessCircle = {
//       radius: number;
//   }</code></pre>
<p>This gets you the same result</p>
<pre class="language-typescript"><code class="language-typescript">type RemoveKindField<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = {
    [K in Exclude<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keyof</span> <span class="token attr-name">T,</span> <span class="token attr-name">"kind"</span><span class="token punctuation">></span></span>]: T[K]
};</code></pre>
<p>Where this feature shines is when you would like to remap the keys using template literal type with having the old key to extract the original value type.</p>
<p>Example from typescript docs:</p>
<pre class="language-typescript"><code class="language-typescript">type Getters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span> = {
    [K in keyof T as `get${Capitalize<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">&amp;</span> <span class="token attr-name">K</span><span class="token punctuation">></span></span>}`]: () => T[K]
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Person</span><span class="token punctuation">></span></span>;
//   ^ = type LazyPerson = {
//       getName: () => string;
//       getAge: () => number;
//       getLocation: () => string;
//   }</code></pre>

    </article>
</body>
</html>

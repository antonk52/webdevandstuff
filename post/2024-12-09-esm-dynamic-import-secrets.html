<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ESM dynamic import secrets</title>
    <meta name="description" content="Things you don't know about dynamic imports in ECMAScript modules.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.6.1/github-markdown.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            box-sizing: border-box;
            margin: 0;
        }

        .markdown-body {
            min-width: 200px;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #0d1117;
            }
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --fgColor-default: #e6edf3;
            }
        }
        @media (prefers-color-scheme: light) {
            :root {
                --fgColor-default: #1f2328;
            }
        }

        header {
            display: flex;
            gap: 24px;
            border-bottom: 1px solid #e1e4e8;
            padding: 16px 24px;
        }
        header a {
            color: var(--fgColor-default);
        }
        .markdown-body h1 > a,
        .markdown-body h2 > a,
        .markdown-body h3 > a,
        .markdown-body h4 > a,
        .markdown-body h5 > a,
        .markdown-body h6 > a {
            color: var(--fgColor-default);
            text-decoration: none;
        }
    </style>
</head>

<body>
    <header>
        <a href="/webdevandstuff">Web dev and stuff</a>
        <a href="https://github.com/antonk52" target="_blank">GitHub</a>
        <a href="https://twitter.com/antonk52" target="_blank">Twitter</a>
    </header>

    <article class="markdown-body">
        <h1>ESM dynamic import secrets</h1>
        
        <h1 id="esm-dynamic-import-secrets"><a href="#esm-dynamic-import-secrets">ESM dynamic import secrets</a></h1>
<p>Import calls A.K.A. <code>import()</code> has been a <a href="https://tc39.es/ecma262/#sec-import-calls">part</a> of the ECMASpec for almost a decade. Besides allowing to dynamically import javascript modules it has a couple of gotchas and more tricks up its sleeve. Let&#39;s dig in.</p>
<h2 id="thing-you-can-import"><a href="#thing-you-can-import">Thing you can import</a></h2>
<p>All modern run times i.e. browser/node/deno/bun/etc support the most common cases</p>
<ul>
<li>Relative paths <code>import(&#39;./module.js&#39;)</code></li>
<li>Absolute paths <code>import(&#39;/Users/username/project/module.js&#39;)</code></li>
<li>Http[s] URLs <code>import(&#39;https://example.com/module.js&#39;)</code></li>
<li>File URLs <code>import(&#39;file:///Users/username/project/module.js&#39;)</code></li>
<li>Data URLs <code>import(&#39;data:text/javascript,export default 42&#39;)</code></li>
</ul>
<p>Some run times may extend the supported cases and add other supported protocols. Example: nodejs supports <code>node:*</code> protocol to import <a href="https://nodejs.org/api/esm.html#node-imports">node&#39;s builtin modules</a>.</p>
<p>Before NodeJS added support for <code>require</code>&#39;ing ES modules, dynamic import was the only way to load ES modules from a CommonJS module.</p>
<h2 id="secret-1-windows-paths"><a href="#secret-1-windows-paths">Secret 1: windows paths</a></h2>
<p>Absolute paths are tricky. The following code will work on MacOS and Linux but will fail on Windows.</p>
<pre><code class="language-javascript">// file.cjs

import path from &#39;node:path&#39;;

import(path.join(__dirname, &#39;module.js&#39;));
</code></pre>
<p>On unixy systems this resolves to</p>
<pre><code class="language-javascript">import(&#39;/Users/username/project/module.js&#39;);
</code></pre>
<p>On Windows this resolves to</p>
<pre><code class="language-javascript">import(&#39;c:\\Users\\username\\project\\module.js&#39;);
</code></pre>
<p>And results in an error:</p>
<blockquote>
<p>Only URLs with a scheme in: file, data, and node are supported by the default ESM loader. On Windows, absolute paths must be valid file:// URLs. Received protocol &#39;c:&#39;</p>
</blockquote>
<p>This throws an error as <code>c:</code> is not a supported protocol. In order to fix it you need to signal that the following is a file path. This can be done by using a supported file URL protocol</p>
<pre><code class="language-javascript">import(&#39;file://c:\\Users\\username\\project\\module.js&#39;);
</code></pre>
<p>Now this will work as expected. But how can we do this? This brings us to the next secret.</p>
<h2 id="secret-2-importmeta"><a href="#secret-2-importmeta">Secret 2: import.meta</a></h2>
<p><a href="https://tc39.es/ecma262/#sec-meta-properties"><code>import.meta</code></a> is a special object that is available on import keyword. Among other things it contains an utility method that can help us <code>import.meta.resolve()</code>. It resolves a module specifier to a URL</p>
<blockquote>
<p>import.meta.resolve() is a built-in function defined on the import.meta object of a JavaScript module that resolves a module specifier to a URL using the current module&#39;s URL as base.</p>
</blockquote>
<p><small>source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve">MDN</a></small></p>
<p>Sounds exactly what we need.</p>
<pre><code class="language-javascript">// file.cjs
import(import.meta.resolve(&#39;module.js&#39;));
</code></pre>
<p>This works in ES modules. But since our file is a CommonJS module it throws an error as <code>import.meta</code> can only be using from within ES modules. For this reason in CommonJS files we have to fallback to node&#39;s builtin utility</p>
<pre><code class="language-javascript">// file.cjs
import url from &#39;node:url&#39;;

import(url.pathToFileURL(path.join(__dirname, &#39;module.js&#39;)));
</code></pre>
<p>Hooray, it works on all platforms.</p>
<h2 id="eval-javascript"><a href="#eval-javascript">Eval JavaScript</a></h2>
<p>As you could notice, besides importing modules from URLs you can also import from data URLs. This can be used to eval JavaScript code.</p>
<pre><code class="language-javascript">const mod = await import(&#39;data:text/javascript,export default 42&#39;);

console.log(mod.default); // 42
</code></pre>
<p>At first glance this may look like a good old <code>eval</code>. But it is not. The code is executed in a separate context and does not have access to the current scope. This is good not only for security reasons but also for correctly attributing errors.</p>
<h2 id="secret-3-keep-source-maps-for-generated-code"><a href="#secret-3-keep-source-maps-for-generated-code">Secret 3: Keep source maps for generated code</a></h2>
<pre><code class="language-javascript">const mod = await import(&#39;data:text/javascript,export default 42\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjoiMS4wLjAifQ==&#39;);
</code></pre>
<p>Now if during the execution of our new &quot;virtual&quot; module an error occurs, the error will be correctly attributed to the original source file.</p>

    </article>
</body>
</html>
